#### 2023.8.2 | 객체지향 디자인 패턴

#### 생성(Creational)

클래스에 대한 인스턴스를 생성, new 라는 연산자를 이용해서 인스턴스를 생성하는 것이 굉장히 중요한데 인스턴스를 생성하는 방법들을 패턴으로 설명을 하고 있는 것이다. 객체를 생성하는 프로세스를 보다 유연하고 독립적으로 만드는 데 사용됩니다. 생성 패턴을 사용하면 시스템이 객체의 구체적인 타입에 의존하지 않고도 객체를 생성할 수 있게 해준다. 

- 싱글톤(Singleton) 패턴: 오직 하나의 인스턴스만 생성하고, 전역적인 접근이 필요한 경우 사용됩니다.
- 팩토리(Factory) 패턴: 객체를 생성하는 인터페이스를 제공하고, 하위 클래스가 어떤 클래스의 인스턴스를 생성할지 결정하도록 합니다.
- 추상 팩토리(Abstract Factory) 패턴: 여러 관련 객체들을 함께 생성하고, 이들 객체의 인터페이스를 정의하는 추상 팩토리를 제공하니다.
- 빌더(Builder) 패턴: 복잡한 객체의 생성 과정을 단계별로 나누어 처리하며, 동일한 생성 프로세스에서 다른 표현 결과를 만들 수 있도록 합니다.
- 프로토타입(Prototype) 패턴: 원본 객체를 복제하는데, 복ㅈ바한 초기화 과정을 거칠 필요 없이 객체를 생성합니다. 

#### 구조(Structural)

클래스와 인터페이스, 추상클래스들의 구조를 표현하는 것이다. 클래스나 객체를 서로 더 크고 복잡한 구조로 구성하는 방법에 관한 패턴이다.

- 어댑터(Adapter) 패턴: 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작하도록 변환시켜줍니다.
- 브리지(Bridge) 패턴: 추상화와 구현부를 분리하여 각각 독립적으로 변형할 수 있게 해줍니다.
- 컴포지트(Composite) 패턴: 객체들을 트리 구조로 구성하여 단일 객체와 복합 객체를 동일하게 다룰 수 있게 합니다.
- 데코레이터(Decorator) 패턴: 객체에 추가적인 기능을 동적으로 덧붙일 수 있게 해줍니다.
- 파사드(Facade) 패턴: 복잡한 서브시스템을 단순화된 인터페이스로 제공하여 사용하기 쉽게 만듭니다.
- 플라이웨이트(Flyweight) 패턴: 메모리 사용량을 줄이기 위해 객체를 공유하여 사용하고, 객체의 내부 상태는 외부에서 조작하지 않습니다.
- 프록시(Proxy) 패턴: 접근 제어를 위한 대리자를 제공하여 객체에 대한 간접적인 접근을 제어합니다.

#### 행위(Behavioral)

메소드가 호출되었을 때 경우에 따라서 어떻게 해야 좋은지 표현하는 것이다. 

객체 간의 책임과 알고리즘을 조직화하는 패턴입니다. 객체들 사이의 협력 방식을 정의하며, 복잡한 흐름 제어를 더 간결하고 유연하게 만들 수 있다. 객체 간의 커뮤니케이션과 책임을 명확하게 구분해 주어 설계를 더욱 견고하게 만든다. 

- 옵저버(Observer) 패턴: 객체 간의 일대다 종속 관계를 정의하여, 한 객체의 상태 변경이 다른 객체에 자동으로 알림을 주는 방식으로 동작합니다.
- 스트래티지(Strategy) 패턴: 동일한 문제를 해결하기 위해 여러 알고리즘을 정의하고, 이를 동적으로 교체하여 사용할 수 있게 합니다.
- 스테이트(State) 패턴: 객체의 내부 상태에 따라 행위를 변경할 수 있도록 하며, 객체가 자신의 상태에 따라 행동을 적절하게 변경합니다.
- 책임 연쇄(Chain of Responsibility) 패턴: 요청을 처리할 수 있는 객체들을 연결하여, 어떤 객체가 요청을 처리할지 결정하는 메커니즘을 제공합니다.
- 커맨드(Command) 패턴: 요청을 객체의 형태로 캡슐화하여, 요청을 보내는 객체와 요청을 수행하는 객체를 분리시킵니다. 