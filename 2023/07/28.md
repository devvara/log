#### 2023.7.28 | OAuth - OAuth 2.0

#### OAuth 2.0 인가 프레임워크

OAuth 2.0은 현재 가장 널리 사용되고 있는 인가 프로토콜과 버전이다.

OAuth 2.0에서는 Scope 기능이 추가되었다. 
OAuth 1.0에서는 토큰이라는 값만 있으면 사용자의 모든 리소스에 접근을 할 수 있었다. 이는 사용자가 필요한 자원 이외에도 접글 할 수 있는 문제를 야기한다. OAuth 2.0에서는 Scope라는 기능을 추가를 해서 해당 토큰에 대해서 접근 범위를 설정할 수 있게 되었다. 

OAuth 2.0에서는 Client 복잡성이 간소화되었다. 
OAuth 1.0은 보안을 위해 암호학적 기반 보안책들을 사용을 했다. 하지만 암호학적 보호를 받기 위해서는 서명을 한 원본을 만들어야 하는데 이 원본을 만들기 위해서 HTTP 메서드뿐만 아니라 URI, 여러 파라미터, 어떤 파라미터를 넣을지 안 넣을지 어떤 순서로 넣을지에 대한 정확한 분류가 필요했다. 이 문제를 OAuth 2.0에서는 Bearer Token과 TLS를 사용을 해서 해결을 했다. Bearer Token이라는 것은 다른 암호학적 보호나 클라이언트에 바인딩 되는 장치들을 모두 배제를 한 채 해당 토큰을 소유를 하고 있는 것만으로도 토큰에 대한 사용 권한이 있음을 인정을 할 수 있는 토큰을 이야기한다. 소유를 하고 있는 것만으로도 권한이 생기므로 OAuth 2.0에서는 HTTPS를 강제를 하게 되었다.

OAuth 1.0 Server의 역할
OAuth 1.0 Server는 Resource Owner 인증하는 역할, 인가 토큰을 발급하는 역할, 보호된 리소스를 관리하는 세 가지 역할을 가지고 있는 데 OAuth 2.0에서는 Resource Owner 인증, 인가 토큰을 발급하는 역할을 OAuth 2.0 Authz Server에서 보호된 리소스를 관리하는 역할을 OAuth 2.0 Resource Server로 분리를 함으로써 아키텍처를 개선을 하였다. 

토큰 탈취 문제 개선
OAuth 1.0에서는 토큰의 유효기간이 길었다. 6개월, 1년의 긴 토큰의 유효 기간이 있었는데 이것의 문제는 토큰이 탈취되었을 때 일시적으로 토큰을 사용해서 어뷰징을 할 수 있는게 아닌 지속적으로 긴 기간동안 어뷰징할 수 있기 때문에 문제가 되었다. OAuth 2.0에서는 이 문제를 해결하기 위해 Refresh Token이라는 개념을 새롭게 만들었다. Resource를 접근을 할 때는 Access Token을 사용해서 접근을 하는 데 해당 토큰은 굉장히 짧은 유효 기간을 가지고 있다. 하지만 Server To Sever 통신을 통해 발급을 받은 Refresh Token을 사용한다면 새로운 Access Token을 받아서 Resource 접근을 할 수 있다. 이 방식을 사용하게 된다면 Access Token이 탈취가 되더라도 Access Token이 유효한 짧은 기간만 어뷰징이 가능하기 때문에 보안성을 개선할 수 있다. Refresh Token은 긴 유효기간을 가지고 있고 Access Token은 짧은 유효기간을 가지고 있다. 

제한적인 사용 환경
OAuth 1.0의 문제점은 사용 환경이 제한적이었다. OAuth 1.0은 웹 브라우저 환경에서 작동되도록 최적화되어 있고 다른 환경에서는 사용하기 굉장히 어려운 프로토콜이었다. OAuth 2.0에서는 Grant라는 개념을 추가해 다양한 사용 환경에 대한 플로우를 나타나는 인증 방식이다. OAuth 2.0 기본 스펙에 추가가된 Grant Type은 Authorizationn Code, Implicit, Resource owner password credentials, Client credentials 이 있다.

1. Authorization Code: OAuth 1.0과 동일한 플로우

이 방식은 대부분의 웹 애플리케이션에서 선호하는 방식으로, 사용자를 인증 서버로 리디렉션하고, 인증 성공 후에 애플리케이션으로 다시 리디렉션합니다. 리디렉션 URL에는 "code"라는 이름의 authorization code가 포함됩니다.

예시: Google이나 Facebook을 통해 로그인하는 서비스에서 주로 이 방식을 사용합니다.

2. Implicit: 직접적으로 로그인 인증 후에 토큰을 발급을 받는 플로우

이 방식은 주로 JavaScript 같은 클라이언트 사이드 언어에서 실행되는 애플리케이션에 사용됩니다. 이 방식은 authorization code를 거치지 않고 바로 access token을 반환합니다.

예시: 클라이언트 사이드 웹 애플리케이션에서 주로 이 방식을 사용합니다.

3. Resource Owner Password Credentials: 직접적으로 유저 정보가 이동되는 만큼 유저가 가지고 있는 기기의 OS와 같은 빋을 수 있는 안정한 환경에서만 사용되는 플로우 

이 방식은 사용자의 username과 password를 직접 요구합니다. 이 방식은 사용자가 애플리케이션을 신뢰하고 애플리케이션이 사용자 이름과 비밀번호를 안전하게 처리할 수 있다고 확신할 때만 사용해야 합니다.

예시: 애플리케이션과 백엔드 서버간의 통신 또는 신뢰할 수 있는 애플리케이션에서 이 방식을 사용할 수 있습니다.

4. Client Credentials: Resource Owner와 OAuth Client가 동일한 하나의 개체일때 복잡한 플로우를 가져가기 보다 직접적으로 API 호출을 통해 토큰을 발급받는 플로우

이 방식은 애플리케이션이 자체적으로 (즉, 사용자의 대화 없이) 인증을 수행해야 할 때 사용됩니다. 이 방식은 애플리케이션이 서버에 대해 인증해야 하는 상황에서 주로 사용됩니다.

예시: 백엔드 서비스에서 다른 서비스로 API 요청을 보낼 때 이 방식을 사용할 수 있습니다.